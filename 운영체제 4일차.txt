<인터럽트 비동기적 사건을 알려줌>
컨텍스트 스위칭(자원소모가 큼)
인터럽트를 사용하면 IO작업을 기다리지 않고 다른작업이 같이 이루어짐

인터럽트 처리할때 어떻게 하느냐

하드웨어
인터럽트를 발생시킴
처리기(CPU)가 현재 명령어의 실행을 완료
장치제어기에 인터럽트 확인신호를 보냄
CPU는 PSW,PC를 제어스택에 저장함
인터럽트를 PC에 적재
소프트웨어
프로세스의 나머지 상태 정보를 저장(CPU REGISTER)
인터럽트 처리
프로세스의 상태정보를 복구
이전 PSW PC를 복구


N+1의 CPU값을 그대로 복구해서 실행한다.
인터럽트 > 스택에 저장
컨텍스트 스위칭 > 커널에 저장(Process Control Block)

순차적 인터럽트 처리
하나의 인터럽트가 처리중에는 다른 인터럽트를 불능화
인터럽트의 중첩을 허용하지 않음
문제점: 우선순위나 시간 긴급도를 고려하지 않음

다중 인터럽트
중첩된 인터럽트 처리 허용
우선순위가 높은애를 먼저 실행시킬 수 있다

1.응용체제에서 시스템콜을 호출할 경우
2.디바이스에서 인터럽트를 요청할경우
시스템콜도 인터럽트로 구현된다.
OS는 PASSIVE하다.
운영체제에서 인터럽트가 중요하다
(1억번 강조함)

<메모리 계층 구조>
보드내 메모리 (레지스터, 주기억창치
레지스터는 CPU 속도와 동일하다
캐시는 2배정도
주기억장치는 30배정도 느림

보드외 메모리 (자기 디스트, 플래쉬 메모리)

오프라인 저장장치
잘안씀

-빠르면 비쌈
-용량이 크면 느리고 쌈

2차메모리
-비휘발성
-외부저장장치
-프로그램과 데이터파일을 저장하기 위해 사용
주기억장치는 다 날라감

<캐시메모리>
캐시
-빠른저장장치에 정보를 복사해 놓는 기법
-최근에 접근한 데이터를 저장
-캐시데이터를 항상 상대적으로 느린 저장장치에 정보를 백업하진 않고 캐시에서 사용중단될때 상대적으로 느린 저장장치에 정보를 업데이트한다.

캐시원칙
-주메모리 한 영역에 복사본을 가지고 있음
-CPU는 캐시를 우선참조
-없으면 필요한 정보가 캐시로 올라옴
-참조지역성 때문에 향후 참조될 데이터는 캐시에 존재할 가능성이 높음

참조지역성
짧은 시간엔 고정된 클러스터에 메모리접근이 한정되는 경향이 있다
명령어: 반복문, 서브루틴
데이터: 테이블, 배열 - 계속해서 비슷한 정보에 접근함

캐시는 데이터 일관성 문제가 있다

캐시원칙
작은 크기의 캐시도 성능에 큰 영향을 미침
블록의 크기가 클수록 적중률이 높다 -> 캐시는 비싸다;
매핑함수
교체알고리즘
-가장 최근에 이용하지않은 녀석을 교채시킴
쓰기정책
어느시점에 캐시메모리 데이터를 메인메모리에 쓸것인가
메인메모리의 데이터가 최신이 아님

<입출력 통신기술>
프로그램된 입출력
인터럽트 구동 입출력
직접 메모리 접근

프로그램된IO
CPU > IO 입출력 모듈에 읽기 명령 - CPU는 다른일 수행가능
IO > CPU 입출력 모듈의 상태읽기 (무한루프)
준비됨
입출력 모드로 부터 워드 읽기
메모리에 워드 기록
완료
>>CPU를 거치기 때문에 비효율적이다

DMA
디바이스 제어기는 메모리 사이클 훔침 기법을 이용한다
(버스를 사용하지 않을때 이용한다)
CPU > DMA 
DMA > CPU

<하드웨어 보호>
4가지

이중 모드 연산
운영체제의 연산과 일반 프로그램의 연산을 구분해준다
1. 사용자 모드
2. 시스템 모드 (커널 모드)
구분하는 이유: 유저모드에서 못하는 연산을 커널모드의 연산들을 지원해주기 위해.
PSW에 비트가 설정되어있음 무슨 모드인지
모드 비트를 이용하여 현재의 모드가 시스템 모드인지 사용자 모드인지를 알려주는 하드웨어 지원
인터럽트가 발생하거나 장애가 발생하면 하드웨어는 시스템 모드로 모드를 전환 시킨다.
특권명령어는 시스템 모드에서만 수행가능

IO보호
모든 IO 명령은 특권명령어이다
IO연산을 유저에게 풀어버리면 병행처리등이 잘 제어가 안된다.

메모리 보호
메모리를 오염시키면 오동작을 하기때문에 방지하기 위해 주소영역을 넘어갈 수 없다.
명령어 범위가 벗어나는지 매 CPU사이클마다 체크한다. 벗어나면 OS가 프로그램을 종료시킨다

CPU 보호
OS 는 PASSIVE 하다
타이머 - 한 프로그램이 OS를 독점해서 다른데서 실행할 수 없다면 안되기 때문에 일정한 시간이 지나면 OS가 수행될 수 있도록 인터럽트를 걸어준다
타이머는 시분할 시스템을 구현하기 위해서도 사용된다.


OS 하드웨어를 이해하기 위한 기본적인 지식을 배웟다
<<<1장 END>>>

<운영체제 개요>
리소스(물리적, 논리적)를 효율적으로 사용할 수 있도록 조정자역할을 함

목적
편리성 - 컴퓨터를 편리하게 사용할 수 있게
효율성 - 자원을 효율적인 방법으로 사용
발전성 - 새로운 기능 도입을 다른서비스를 방해하지 않고 되야함

유닉스가 표준이기 때문에 개발언어도 C가 표준으로 사용된다
디바이스 드라이버 같은 프로그램이 C
사용자 관점
컴퓨터를 쉽게 사용할 수 있고 컴퓨팅환경을 제공해줌
여러 기능을 수행 (파일접근, 입출력장치 접근 등)

소프트웨어로서의 운영체제
처리기에 의해 실행되는 프로그램
응용에게 제어를 양도해가며 실행되고
특정 CPU기능을 통해 응용으로부터 제어를 넘겨 받는다
멀티코어 4, 8, 16, 64 ...
매니코어
* 병렬 프로그래밍

백엔드 개발자
기능구현 -> 최적화

커널
주 메모리에 상주하는 운영체제의 핵심 (혹은 하드디스크의 스왑스페이스)
자주 사용되는 기능을 포함
뚜렷한 정의는 없음

운영체제 발전의 용이성
운영체제의 버전을 업그레이드 하는 이유
하드웨어 업그레이드와 새로운 형태의 하드웨어의 지원
어떤 운영체제도 결함(버그)을 가지고 있음

<운영체제의 발전>
숫자 처리
- 운영체제 없음
- 발광체, 토글, 스위치, 입력장치, 프린터로 구성된 콘솔
문제점: 실행을 위한 준비시간이 너무 길었다


단순 일괄 처리 시스템 (batch processing)
모니터
- 일련의 이벤트를 제어하는 소프트웨어
- 일괄처리 작업

job control language (jcl)
- 모니터에 명령어 제공 (인터럽트 처리, 장치드라이버, 작업 순서화, 제어언어 인터프리터)
- 포트한 언어
- 용지에 명령어를 씀
(교수 과거 회상씬- 나때는 컴파일할때 하루씩 걸림 ㅋ)

하드웨어 기능
메모리 보호, 타이머, 특권명령어, 인터럽트

단일 프로그래밍
하나의 프로세스만 실행
cpu는 IO명령을 대기해야함

멀티 프로그래밍
여러개의 프로그램이 메모리에 올라와 cpu를 번갈아가면서 실행
cpu 이용률의 극대화
멀티 프로그래밍을 위한 운영체제 기능의 확대
-운영체제에 의해 io작업이 수행
-메모리 관리(단일프로그래밍에선 필요없음)
-cpu스케줄링

한작업이 입출력을 대기해야 할때, cpu는 다른작업으로 제어를 넘김

멀티 프로그래밍이 단일 프로그래밍보다 좋다































