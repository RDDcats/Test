운체 
답안은 키워드 중심으로 적어라

<프로세스 기술: OS>
OS 제어구조
개체를 위한 테이블이 구성됨
- 메모리 테이블
- IO테이블
- 파일 테이블
- 프로세스 테이블

메모리 테이블
주기억장치 정보
2차 메모리 정보(스왑스페이스)
보호속성
가상메모리 정보
segment table, page table

IO테이블
IO연산에 필요한 정보 유지
- IO 장치 이용가능 or 특정 프로세스에 할당정보
- IO 버퍼 위치, 주기억장치 위치

파일테이블
- 2차메모리에서 위치
- 현재 상태, 속성
- 파일 정보라던지 파일 시스템 정보

<Process Context>
리눅스에선 process를 task라고 부른다
문맥(Context)
커널이 관리하는 태스크의 자원과 제어 흐름의 집합

시스템 문맥
메모리 문맥
하드웨어 문맥 > 컨택스트 스위치때 저장되어야되는 것 
하드웨어 문맥 = cpu Register

문맥 구조
메모리 컨택스트 = 프로세스 이미지가 올라와 있는 메인 메모리의 주소공간에 대한 정보
이건 세그먼트 테이블과 페이지 테이블상에 어느위치에 올라와있는 지에 대한 정보를 가지고 있음

TSS 자료구조
eip, sp, eax등 cpu레지스터 값이 저장되는 공간

메모리 컨택스트와 하드웨어 컨택스트를 제외한 모든 정보는 시스템 컨텍스트라고 부른다.

fork() - 오버해드가 크다

fork()가 오버해드가 크기때문에 멀티 쓰레드가 나왔다

쓰레드는 명령어의 흐름이다
실행과 관련된 자료구조 stack과 cpu register가 쓰레드 별로 존재해야하고 그외 나머지 자료구조는 공유 가능

fork()할때는 모든 구조를 복사해서 자식을 생성하기때문에 쓰레드를 발생하는것은 더 효율적이다

프로세스 테이블
- PCBs(프로세스 컨트롤 블락)을 빠르게 접근할수 있게 한다


프로세스마다 pcb 포인터를 가지게 된다.
프로세스를 생성하면 프로세스 관리를 위한 정보를 저장하게되는데 이런 정보가 프로세스 속성이라고 한다
프로세스 제어블록 = 속성들의 집합이다
프로세스 테이블은 프로세스 제어블록 위치에 대한 포인터를 모아둔다
프로세스가 종료되면 다 반환한다

cpu 레지스터는 cpu를 뺏길때만 저장한다 (프로세스제어블록에) 리눅스에선 TSS자료구조에
cpu를 다시 할당받으면 복원이 된다.

PCB 들어있는거
프로세스 식별자 : pid, ppid, uid 등
처리기 상태정보 : cpu레지스터 값(프로그램 카운터 포함)
프로세스 제어정보 : 
컨텍스트의 모든정보 (프로세스를 관리하기위한 모든정보)
>>계속 같은말 반복함


프로세스 리스트 구조
수행 > 프로세스 제어블록
준비 > cpu 스케줄링 알고리즘
블록 > io작업도 큐로 구현 가능?

<프로세스 제어>
모드 전환
대부분의 cpu는 2가지 모드가 있다
1. 사용자 모드
2. 시스템 모드(커널 모드)
시스템 콜을 호출하면 커널모드로 바뀌어서 실행된다.
중간에 인터럽트가 걸리면 커널모드로 동작한다.
프로세스는 유저모드와 커널모드를 왔다갔다하면서 동작한다

모드 전환은 - 유저모드 <=> 커널모드 의 전환이다

프로세스 교환 : cpu를 p1이 할당받아 실행되고 있을때 이걸 뺏고 p2에게 할당하는것
선점(cpu 뺏기) 및 디스패치 (레디큐에있는거 하나를 할당)
문맥 교환
p1의 cpu레지스터를 pcb에 저장
p2의 pcb정보를 cpu레지스터로 복원

<프로세스 교환을 유발하는 사건>
1. Clock interrupt
2. IO 인터럽트
3. 메모리 폴트
4. 트랩
5. 수퍼바이저 호출

프로세스를 생성할때 많은 작업이 실행된다
프로세스를 종료하는것도 만만치 않다


<<9장 단일처리기 스케줄링>>
장기, 중기 단기 스케줄링 기법 학습
스케줄링 성능 분석 방법

장기 - 스케줄링프로세스가 cpu에 의해 실행될수 있는 자격을 부여할지 말지 여부를 결정, degree of 멀티프로그래밍을 결정 몇개의 프로그램이 돌아가는지.
단기 - cpu에 의해 다음에 실행될 프로세스 선택 (= 디스패처)

>>스케줄링 알고리즘은 다음에 실행할 요청을 고르는것























































